import os
from datetime import datetime, timezone
from configparser import ConfigParser
from typing import List, OrderedDict
import zipfile
from xml.sax import saxutils
from math import ceil
from shutil import make_archive, rmtree, move
import statistics
from zoneinfo import ZoneInfo

from docx import Document
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
from docx.shared import Inches, RGBColor, Pt

from app import core_app
from app.db.connections.main_db import MainDatabase
from app.db.crud.target import CrudTarget
from app.enums.main import ScanStatus, SeverityIndex, AlertStatus
from app.db.crud.scan_result import CrudScanResult, CrudDSScanResult
from app.db.models.target import Target
from app.utils import common_utils
from app.utils import file_utils
from app.utils import chart_utils
from app.utils.cvss_utils import calculate_cvss_by_severity


class Reporter(object):
    def __init__(self, target: Target):
        self.target = target

        self.report_root_path = core_app.settings.output_dir

        template_dir = os.path.join(core_app.settings.config_dir, "report_templates")
        self.report_template = os.path.join(template_dir, "base_template.docx")
        self.executive_summary_tpl = os.path.join(
            template_dir, "executive_summary.conf"
        )

        self.target_tmp_dir = os.path.join(
            core_app.settings.local_temp_dir, str(self.target.id)
        )

        self.pie_chart_path = os.path.join(self.target_tmp_dir, "pie_chart.png")
        self.bar_chart_path = os.path.join(self.target_tmp_dir, "bar_chart.png")

        self.document = Document(self.report_template)
        self.records = []
        self.added_alerts = 0

        self.critical_count = 0
        self.high_count = 0
        self.medium_count = 0
        self.low_count = 0
        self.info_count = 0

        # self.alerts_distribution_by_host = {}
        self.overall_cvss_score_by_host = {}
        self.overall_cvss_score = 0

    def run(self):
        try:
            os.makedirs(self.target_tmp_dir, exist_ok=True)

            self.prepare_report()
            self.add_executive_summary()

            if self.target.is_ip_range():
                self.multiple_ips_report()
            else:
                self.single_target_report()

            output_dir = os.path.join(
                self.report_root_path,
                self.target.customer_username,
                str(self.target.id),
            )
            os.makedirs(output_dir, exist_ok=True)
            output_path = os.path.join(output_dir, "report.docx")
            self.document.core_properties.author = "IVA"
            self.document.core_properties.comments = "Generated By IVA"
            self.document.save(output_path)
            self.adjust_cover_page(output_path)

            with MainDatabase() as db:
                crud_target = CrudTarget(db)
                self.target.scan_status = ScanStatus.ENUM.REPORT_GENERATED
                self.target.overall_cvss_score = self.overall_cvss_score
                self.target.cvss_score_by_host = self.overall_cvss_score_by_host
                crud_target.mark_as_completed(self.target)
        finally:
            if os.path.exists(self.target_tmp_dir):
                rmtree(self.target_tmp_dir)

    def calculate_severities(self):
        if not self.records:
            return 0

        cvss_distro_by_host = {}
        overall_cvss_distro = {}

        is_ip_range = self.target.is_ip_range()
        for record in self.records:
            severity = record.get("severity")

            if is_ip_range:
                host = record.get("network_details").get("ip")
            else:
                host = "single"

            if not host:
                continue

            if severity:
                if severity == SeverityIndex.ENUM.CRITICAL:
                    self.critical_count += 1
                elif severity == SeverityIndex.ENUM.HIGH:
                    self.high_count += 1
                elif severity == SeverityIndex.ENUM.MEDIUM:
                    self.medium_count += 1
                elif severity == SeverityIndex.ENUM.LOW:
                    self.low_count += 1
                else:
                    self.info_count += 1

            cvss_distro = cvss_distro_by_host.get(host, {})
            cvss_score = None
            try:
                cvss_score = float(record["classification"]["cvss_score"])
            except Exception:
                pass

            if not cvss_score:
                cvss_score = calculate_cvss_by_severity(severity)

            if not cvss_score:
                continue

            if cvss_score >= 0 and cvss_score <= 3.9:
                cvss_low = cvss_distro.get("low", [])
                cvss_low.append(cvss_score)
                cvss_distro["low"] = cvss_low

                overall_cvss_low = overall_cvss_distro.get("low", [])
                overall_cvss_low.append(cvss_score)
                overall_cvss_distro["low"] = overall_cvss_low
            elif cvss_score >= 4.0 and cvss_score <= 6.9:
                cvss_medium = cvss_distro.get("medium", [])
                cvss_medium.append(cvss_score)
                cvss_distro["medium"] = cvss_medium

                overall_cvss_medium = overall_cvss_distro.get("medium", [])
                overall_cvss_medium.append(cvss_score)
                overall_cvss_distro["medium"] = overall_cvss_medium
            elif cvss_score >= 7.0 and cvss_score <= 8.9:
                cvss_high = cvss_distro.get("high", [])
                cvss_high.append(cvss_score)
                cvss_distro["high"] = cvss_high

                overall_cvss_high = overall_cvss_distro.get("high", [])
                overall_cvss_high.append(cvss_score)
                overall_cvss_distro["high"] = overall_cvss_high
            elif cvss_score >= 9.0 and cvss_score <= 10.0:
                cvss_critical = cvss_distro.get("critical", [])
                cvss_critical.append(cvss_score)
                cvss_distro["critical"] = cvss_critical

                overall_cvss_critical = overall_cvss_distro.get("critical", [])
                overall_cvss_critical.append(cvss_score)
                overall_cvss_distro["critical"] = overall_cvss_critical

            # update the cvss distribution by host
            if cvss_distro:
                cvss_distro_by_host[host] = cvss_distro

        # self.overall_cvss_score = total_score / cvss_total_entries
        # self.overall_cvss_score = round(self.overall_cvss_score, 1)

        # calculate overall score by host
        if cvss_distro_by_host:
            for host, entries in cvss_distro_by_host.items():
                critical_range = entries.get("critical", [])
                high_range = entries.get("high", [])
                medium_range = entries.get("medium", [])
                low_range = entries.get("low", [])

                overall_by_host = 0.0

                if critical_range:
                    overall_by_host = statistics.median(critical_range)
                elif high_range:
                    overall_by_host = statistics.median(high_range)
                elif medium_range:
                    overall_by_host = statistics.median(medium_range)
                else:
                    overall_by_host = statistics.median(low_range)
                overall_by_host = round(overall_by_host, 1)
                self.overall_cvss_score_by_host[host] = overall_by_host

        if overall_cvss_distro:
            critical_range = overall_cvss_distro.get("critical", [])
            high_range = overall_cvss_distro.get("high", [])
            medium_range = overall_cvss_distro.get("medium", [])
            low_range = overall_cvss_distro.get("low", [])

            if critical_range:
                self.overall_cvss_score = statistics.median(critical_range)
            elif high_range:
                self.overall_cvss_score = statistics.median(high_range)
            elif medium_range:
                self.overall_cvss_score = statistics.median(medium_range)
            else:
                self.overall_cvss_score = statistics.median(low_range)
            self.overall_cvss_score = round(self.overall_cvss_score, 1)

    def prepare_report(self):
        # ! MongoDB stores time in UTC, the get_scan_completed_time() function converts it to local time
        # ! we need to put the current time in scan_completed_time in UTC
        # ! so that it will be converted to local time in the report
        self.target.scan_completed_time = datetime.now(timezone.utc)

        with MainDatabase() as db:
            crud_result = CrudScanResult(db)
            self.records = crud_result.get_list_by_target(self.target)

        self.calculate_severities()
        for _ in range(8):
            self.document.add_paragraph()

        # section = self.document.sections[0]
        # header = section.header
        # header_paragraph = header.paragraphs[0]
        # header_paragraph.text = "IVA"

        self.fill_place_holder()
        # if not self.records:
        #     # if no records, here itself we can save the report
        #     self.document.add_paragraph()
        #     self.document.add_paragraph("\tNo vulnerabilities were found").bold = True
        #     self.document.add_page_break()

    def add_alert(self, alert):
        try:
            alert_index = self.added_alerts + 1
            title = alert.get("vulnerability_title")
            if not title:
                return

            finding = alert.get("finding")
            if not finding:
                return

            cause = alert.get("cause")
            if cause:
                cause = cause.strip("\n")

            network_details = alert.get("network_details", {})
            severity = alert["severity"]
            port = network_details.get("port")

            severity_text = SeverityIndex.get_string(severity)
            if not severity_text:
                return
            effect = alert.get("effect")
            remediation = alert.get("remediation")
            reference = alert.get("reference")
            affected = network_details.get("affected")
            specific_result = network_details.get("specific_result")
            # oid = network_details.get("oid")
            hostname = network_details.get("hostname")

            classification = alert.get("classification", {})
            cvss_score = classification.get("cvss_score")
            cve_details = classification.get("cve_id")

            self.document.add_page_break()
            self.document.add_paragraph()
            self.document.add_heading(f"{alert_index}. {title}", level=2)
            self.document.add_paragraph()

            tabs = "\t\t"
            if not effect or specific_result:
                tabs = "\t\t\t\t"

            severity_text = severity_text.capitalize()
            h1 = self.document.add_heading("Severity" + tabs + ":	", level=2)
            # Color based on Severity Level
            r = h1.add_run(severity_text)
            if severity == SeverityIndex.ENUM.CRITICAL:
                r.font.color.rgb = RGBColor(254, 0, 0)
            elif severity == SeverityIndex.ENUM.HIGH:
                r.font.color.rgb = RGBColor(234, 117, 0)
            elif severity == SeverityIndex.ENUM.MEDIUM:
                r.font.color.rgb = RGBColor(255, 153, 0)
            elif severity == SeverityIndex.ENUM.LOW:
                r.font.color.rgb = RGBColor(0, 0, 204)
            else:
                r.font.color.rgb = RGBColor(0, 102, 0)

            if port:
                port_heading = self.document.add_heading(
                    "Port" + tabs + "\t:	", level=2
                )
                r = port_heading.add_run(port)
                r.font.color.rgb = RGBColor(0, 0, 0)

            if hostname:
                hostname_para = self.document.add_heading(
                    "Hostname " + tabs + ":\t", level=2
                )
                hostname_para.add_run(f"{hostname}")

            if cvss_score:
                cvss_para = self.document.add_heading(
                    "CVSS Score " + tabs + ":\t", level=2
                )
                cvss_para.add_run(f"{cvss_score}")

            fh1 = self.document.add_heading("", level=2)
            fh1r = fh1.add_run("Finding")
            for _ in range(len(tabs)):
                fh1r.add_tab()
            fh1.add_run(":")
            # document.add_heading('Finding ' + tabs + ':', level=2)
            self.document.add_paragraph(common_utils.smart_str(finding))

            if cause:
                if effect:
                    self.document.add_heading("Cause " + tabs + ":", level=2)
                    self.document.add_paragraph(common_utils.smart_str(cause))
                else:
                    self.document.add_heading(
                        "Cause and Effect" + "\t\t\t" + ":", level=2
                    )
                    self.document.add_paragraph(common_utils.smart_str(cause))

                if effect:
                    self.document.add_heading("Effect " + tabs + ":", level=2)
                    self.document.add_paragraph(common_utils.smart_str(effect))

            if specific_result:
                specicif_result = common_utils.smart_str(specific_result)
                specicif_result = specicif_result.replace("\00", "[NULL_BYTE]")
                self.document.add_heading("Additional Details\t\t\t:", level=2)
                self.document.add_paragraph(common_utils.smart_str(specicif_result))

            if affected:
                self.document.add_heading("Affected" + tabs + ":", level=2)
                self.document.add_paragraph(common_utils.smart_str(affected))

            if cve_details:
                self.document.add_heading("CVE Details" + tabs + ":", level=2)
                self.document.add_paragraph(common_utils.smart_str(cve_details))

            if not remediation and severity != SeverityIndex.ENUM.INFO:
                remediation = (
                    "For vulnerabilities related to external software "
                    "or third-party components,"
                    " it is advisable to reach out to the respective software vendor. "
                    "In such cases, apply the patches or updates provided by the vendor"
                    " to effectively remediate the vulnerability."
                )
                remediation += "\n\n"
                remediation += (
                    "For vulnerabilities related to the application code, "
                    "it is advisable to reach out to the application developer."
                    " In such cases, apply the patches or updates provided by"
                    " the developer to effectively remediate the vulnerability."
                )

            if remediation:
                self.document.add_heading("Remediation" + tabs[:-1] + ":", level=2)
                self.document.add_paragraph(common_utils.smart_str(remediation))

            if reference:
                rh1 = self.document.add_heading("", level=2)
                rh1r = rh1.add_run("References")
                for _ in range(len(tabs)):
                    rh1r.add_tab()
                rh1.add_run(":")
                reference_str = ""
                for ref in reference:
                    reference_str += ref + "\n\n"
                self.document.add_paragraph(reference_str)

            self.added_alerts += 1
        except Exception as e:
            core_app.logger.exception(e)

    def single_target_report(self):
        if not self.records:
            return
        for alert in self.records:
            self.add_alert(alert)

    def multiple_ips_report(self):
        core_app.logger.info("Multi IPs report")

        organized_alerts = self.organize_alerts_by_host(self.records)
        if not organized_alerts:
            return

        for host, alerts in organized_alerts.items():
            self.document.add_page_break()
            host_cvss_score = self.overall_cvss_score_by_host.get(host, 0.0)

            for _ in range(10):
                self.document.add_paragraph()

            host_table = self.document.add_table(rows=2, cols=2)
            host_table.style = "Medium Shading 1 Accent 5"
            host_table.autofit = True

            row_1 = host_table.rows[0].cells
            # font color white and increase font size to 14pt
            f1 = row_1[0].paragraphs[0].add_run("Vulnerabilities for host")
            f1.font.color.rgb = RGBColor(255, 255, 255)
            f1.font.size = Pt(14)

            f2 = row_1[1].paragraphs[0].add_run(host)
            f2.font.color.rgb = RGBColor(255, 255, 255)
            f2.font.size = Pt(14)

            row_2 = host_table.rows[1].cells

            f3 = row_2[0].paragraphs[0].add_run("Overall CVSS Score for this host")
            f3.font.color.rgb = RGBColor(0, 0, 0)
            f3.font.size = Pt(14)

            f4 = row_2[1].paragraphs[0].add_run(str(host_cvss_score))
            f4.font.color.rgb = RGBColor(0, 0, 0)
            f4.font.size = Pt(14)

            for alert in alerts:
                self.add_alert(alert)

    def create_chart(self):
        """
        Add a pie & bar chart to the report
        """
        try:
            # Remove the old charts
            if os.path.exists(self.pie_chart_path):
                os.remove(self.pie_chart_path)
            if os.path.exists(self.bar_chart_path):
                os.remove(self.bar_chart_path)

            alerts_distribution = OrderedDict(
                {
                    "Critical": self.critical_count,
                    "High": self.high_count,
                    "Medium": self.medium_count,
                    "Low": self.low_count,
                    # "Info": self.info_count,
                }
            )

            if (
                self.critical_count > 0
                or self.high_count > 0
                or self.medium_count > 0
                or self.low_count > 0
            ):
                # Create Pie chart only, if vulnerability exists
                chart_utils.create_chart(
                    alerts_distribution, self.pie_chart_path, chart_type="donut"
                )
                chart_utils.create_chart(
                    alerts_distribution, self.bar_chart_path, chart_type="bar"
                )

        except Exception as ex:
            core_app.logger.exception(ex)

    @classmethod
    def organize_alerts_by_host(cls, records: List) -> dict | None:
        if not records:
            return None

        organized_alerts = {}

        for record in records:
            host = record.get("network_details").get("ip")
            if not host:
                continue

            alerts = organized_alerts.get(host, [])
            alerts.append(record)

            organized_alerts[host] = alerts

        organized_alerts = dict(sorted(organized_alerts.items()))

        return organized_alerts

    def add_executive_summary(self):
        """
        Function that adds executive summary to the report document
        :return:
        """
        executive_summary_template = ConfigParser()
        executive_summary_template.read(self.executive_summary_tpl)
        summary = executive_summary_template.get("EXECUTIVE_SUMMARY", "summary")
        customer_name = "Customer"
        if customer_name:
            summary = summary.replace(
                "[CUSTOMER]", common_utils.smart_str(customer_name)
            )
        else:
            summary = summary.replace("[CUSTOMER]", "")
        summary = summary.replace(
            "[TARGET]", common_utils.smart_str(self.target.target_address)
        )

        es1 = self.document.add_heading("Executive Summary", 0)
        es1.paragraph_format.page_break_before = True
        self.document.add_paragraph(summary)

        if self.critical_count > 0 or self.high_count > 0:
            risk_level = "High"
        elif self.medium_count > 0:
            risk_level = "Medium"
        elif self.low_count > 0:
            risk_level = "Low"
        else:
            risk_level = "None"

        self.create_chart()

        if risk_level == "None":
            key_points = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", risk_level + "_key_points"
            )
        else:
            key_points = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", risk_level + "_key_points"
            )

        self.document.add_paragraph("")
        self.document.add_heading("Key Points: ", level=2)
        self.document.add_paragraph("\t" + common_utils.smart_str(key_points))

        if os.path.exists(self.pie_chart_path):  # Add Pie Chart
            self.document.add_paragraph("")
            p1 = self.document.add_paragraph()
            p1.add_run().add_picture(
                self.pie_chart_path, width=Inches(4.56), height=Inches(3.30)
            )
            p1.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER  # type: ignore

        if risk_level == "None":
            over_all_risk = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", "None_over_all_risk"
            )
        else:
            over_all_risk = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", "over_all_risk"
            )
            over_all_risk = over_all_risk.replace("[OVER_ALL_RISK]", risk_level)

        self.document.add_paragraph("")

        or1 = self.document.add_heading("Overall Risk: ", level=2)
        if os.path.exists(self.pie_chart_path):
            or1.paragraph_format.page_break_before = True

        self.document.add_paragraph("\t" + over_all_risk)

        if os.path.exists(self.bar_chart_path):  # Add Bar Chart
            self.document.add_paragraph("")
            p2 = self.document.add_paragraph()
            p2.add_run().add_picture(
                self.bar_chart_path, width=Inches(5.2), height=Inches(3.2)
            )
            p2.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER  # type: ignore

        recommendation_section = None
        if not self.records or not self.overall_cvss_score:
            # If there is no alerts, then go for none recommendation
            recommendation_section = "NoActionNeeded_recommendation"
        elif self.overall_cvss_score >= 9.0:
            recommendation_section = "CriticalCVSS_Recommendation"
        elif self.overall_cvss_score >= 7.0:
            recommendation_section = "HighCVSS_Recommendation"
        elif self.overall_cvss_score >= 4.0:
            recommendation_section = "MediumCVSS_Recommendation"
        elif self.overall_cvss_score >= 0.0:
            recommendation_section = "LowCVSS_Recommendation"

        if recommendation_section:
            recommendation = executive_summary_template.get(
                "EXECUTIVE_SUMMARY", recommendation_section
            )

            self.document.add_paragraph("")
            self.document.add_heading("Recommendations: ", level=2)
            self.document.add_paragraph("\t" + common_utils.smart_str(recommendation))

    def fill_place_holder(self):
        """
        Function that fills the place holder in the report document
        :return:
        """
        target_address_for_doc = saxutils.escape(
            common_utils.smart_str(self.target.target_address)
        )
        for paragraph in self.document.paragraphs:
            for run in paragraph.runs:
                if run.text == "PH_TARGET_ADDRESS":
                    run.text = target_address_for_doc
                elif run.text == "PH_STARTED_TIME":
                    run.text = self.target.get_scan_started_time()
                elif run.text == "PH_COMPLETED_TIME":
                    run.text = self.target.get_scan_completed_time()
                elif run.text == "PH_OVERALL_CVSS":
                    run.text = str(self.overall_cvss_score)

    def adjust_cover_page(self, file_name):
        # Temporary Folder for extracting docx files
        target_tmp_dir = os.path.join(
            core_app.settings.local_temp_dir, str(self.target.id)
        )
        report_temp_dir = os.path.join(target_tmp_dir, "temp_report")

        with zipfile.ZipFile(file_name, "r") as z:
            z.extractall(report_temp_dir)  # Extracting into Temporary directory

        if len(self.target.target_address) > 50:
            # When the target address is longer, then increase background image size
            number_of_lines = len(self.target.target_address) / 50
            number_of_lines += 2
            background_image_height = ceil(3190875 + (number_of_lines * 157780))
            file_utils.replace_str_in_file(
                os.path.join(report_temp_dir, "word", "document.xml"),
                'cy="3190875"',
                'cy="' + str(background_image_height) + '"',
            )

        make_archive(
            os.path.join(target_tmp_dir, "tmp_doc"), "zip", report_temp_dir
        )  # Create Zip of Temporary Directory
        os.remove(file_name)  # Remove Old Docx file
        rmtree(report_temp_dir)
        # move the newely generated Docx to the original location
        move(os.path.join(target_tmp_dir, "tmp_doc.zip"), file_name)


class DSReporter(Reporter):

    def __init__(self, target: Target):
        super().__init__(target)

        self.fixed_records = []

    def prepare_report(self):
        # ! MongoDB stores time in UTC, the get_scan_completed_time() function converts it to local time
        # ! we need to put the current time in scan_completed_time in UTC
        # ! so that it will be converted to local time in the report
        self.target.scan_completed_time = datetime.now(timezone.utc)

        with MainDatabase() as db:
            crud_result = CrudDSScanResult(db, self.target.id)
            self.records = crud_result.alerts_by_status(AlertStatus.ENUM.UNFIXED.value)
            self.fixed_records = crud_result.alerts_by_status(
                AlertStatus.ENUM.FIXED.value
            )
        self.calculate_severities()

        for _ in range(8):
            self.document.add_paragraph()

        self.fill_place_holder()

    # For single target report for normal and DS scan
    def single_target_report(self):
        self.add_unfixed(self.records)
        self.add_fixed(self.fixed_records)

    # Add Unfixed alerts
    def add_unfixed(self, alerts):
        if not alerts:
            return

        # reset the added alerts count to 0
        # so that it will reset the count for unfixed and fixed alerts
        self.added_alerts = 0

        self.document.add_page_break()

        # Add spacing before the heading
        for _ in range(10):
            self.document.add_paragraph()

        paragraph = self.document.add_paragraph()
        run = paragraph.add_run("Unfixed Alerts")
        run.font.size = Pt(24)
        paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

        for unfixed_alert in alerts:
            self.add_alert(unfixed_alert)

    # Add Fixed alerts
    def add_fixed(self, alerts):
        if not alerts:
            return

        # reset the added alerts count to 0
        # so that it will reset the count for unfixed and fixed alerts
        self.added_alerts = 0

        self.document.add_page_break()

        # Add spacing before the heading
        for _ in range(10):
            self.document.add_paragraph()

        paragraph = self.document.add_paragraph()
        run = paragraph.add_run("Fixed Alerts")
        run.font.size = Pt(24)
        paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

        for fixed_alert in alerts:
            self.add_alert(fixed_alert)

    def multiple_ips_report(self):
        core_app.logger.info("Multi IPs report")

        organized_unfixed_alerts = self.organize_alerts_by_host(self.records)
        organized_fixed_alerts = self.organize_alerts_by_host(self.fixed_records)

        if not organized_unfixed_alerts and not organized_fixed_alerts:
            return

        self.add_unfixed_for_multiple_ips(organized_unfixed_alerts)
        self.add_fixed_for_multiple_ips(organized_fixed_alerts)

    def add_unfixed_for_multiple_ips(self, alerts_by_host):
        if not alerts_by_host:
            return

        self.document.add_page_break()

        # Add spacing before the heading
        for _ in range(10):
            self.document.add_paragraph()

        paragraph = self.document.add_paragraph()
        run = paragraph.add_run("Unfixed Alerts")
        run.font.size = Pt(24)
        paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

        for host, alerts in alerts_by_host.items():  # type:ignore
            if not alerts:
                continue
            # reset the added alerts count to 0
            # so that it will reset the count for unfixed and fixed alerts
            self.added_alerts = 0

            host_cvss_score = self.overall_cvss_score_by_host.get(host, 0.0)
            self.add_host_section(host, host_cvss_score)

            for unfixed_alert in alerts:
                self.add_alert(unfixed_alert)

    def add_fixed_for_multiple_ips(self, alerts_by_host):
        if not alerts_by_host:
            return

        self.document.add_page_break()

        # Add spacing before the heading
        for _ in range(10):
            self.document.add_paragraph()

        paragraph = self.document.add_paragraph()
        run = paragraph.add_run("Fixed Alerts")
        run.font.size = Pt(24)
        paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

        for host, alerts in alerts_by_host.items():
            if not alerts:
                continue
            # reset the added alerts count to 0
            # so that it will reset the count for unfixed and fixed alerts
            self.added_alerts = 0

            self.add_host_section_for_fixed(host)

            for unfixed_alert in alerts:
                self.add_alert(unfixed_alert)

    # For multiple IPs Target
    def add_host_section(self, host, host_cvss_score):
        """Adds a new section for the host with CVSS score and its alerts."""
        self.document.add_page_break()

        # Add spacing before the table
        for _ in range(10):
            self.document.add_paragraph()

        # Create a table for host and CVSS information
        host_table = self.document.add_table(rows=2, cols=2)
        host_table.style = "Medium Shading 1 Accent 5"
        host_table.autofit = True

        # Add host information
        row_1 = host_table.rows[0].cells
        f1 = row_1[0].paragraphs[0].add_run("Unfixed Vulnerabilities for host")
        f1.font.color.rgb = RGBColor(255, 255, 255)
        f1.font.size = Pt(14)

        f2 = row_1[1].paragraphs[0].add_run(host)
        f2.font.color.rgb = RGBColor(255, 255, 255)
        f2.font.size = Pt(14)

        # Add CVSS score information
        row_2 = host_table.rows[1].cells
        f3 = row_2[0].paragraphs[0].add_run("Overall CVSS Score for this host")
        f3.font.color.rgb = RGBColor(0, 0, 0)
        f3.font.size = Pt(14)

        f4 = row_2[1].paragraphs[0].add_run(str(host_cvss_score))
        f4.font.color.rgb = RGBColor(0, 0, 0)
        f4.font.size = Pt(14)

    # For multiple IPs Target
    def add_host_section_for_fixed(self, host):
        """Adds a new section for the host with CVSS score and its alerts."""
        self.document.add_page_break()

        # Add spacing before the table
        for _ in range(10):
            self.document.add_paragraph()

        # Create a table for host and CVSS information
        host_table = self.document.add_table(rows=1, cols=2)
        host_table.style = "Medium Shading 1 Accent 5"
        host_table.autofit = True

        # Add host information
        row_1 = host_table.rows[0].cells
        f1 = row_1[0].paragraphs[0].add_run("Fixed Vulnerabilities for host")
        f1.font.color.rgb = RGBColor(255, 255, 255)
        f1.font.size = Pt(14)

        f2 = row_1[1].paragraphs[0].add_run(host)
        f2.font.color.rgb = RGBColor(255, 255, 255)
        f2.font.size = Pt(14)

    def add_index(self):
        """
        Adding Index Page for Web VA
        """
        index = 1

        toc1 = self.document.add_heading("Table of Contents", 0)
        toc1.paragraph_format.page_break_before = True

        for i in range(1):
            self.document.add_paragraph("")
        p = self.document.add_paragraph()
        p.add_run(f"{index}. Executive Summary").bold = True
        index += 1

        p1 = self.document.add_paragraph("\t")
        p1.add_run("* ").bold = True
        p1.add_run("Key Points")

        p1 = self.document.add_paragraph("\t")
        p1.add_run("* ").bold = True
        p1.add_run("Distribution of Vulnerabilities")

        p1 = self.document.add_paragraph("\t")
        p1.add_run("* ").bold = True
        p1.add_run("Overall Risk")

        p1 = self.document.add_paragraph("\t")
        p1.add_run("* ").bold = True
        p1.add_run("Recommendations")

        if self.records or self.fixed_records:
            p = self.document.add_paragraph()
            p.add_run(f"{index}. Report").bold = True
            index += 1

        if self.records:
            p1 = self.document.add_paragraph("\t")
            p1.add_run("* ").bold = True
            p1.add_run("Unfixed Alerts")

        if self.fixed_records:
            p1 = self.document.add_paragraph("\t")
            p1.add_run("* ").bold = True
            p1.add_run("Fixed Alerts")
